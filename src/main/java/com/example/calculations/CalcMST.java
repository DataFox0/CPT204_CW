/**
 * MSTApproximation is an approximation method to solve the Traveling Salesman Problem (TSP) with required points
 * using Minimum Spanning Tree (MST).
 * 
 * The core idea of the algorithm is:
 * 
 * 1. **MST (Minimum Spanning Tree)**: Construct a minimum spanning tree (MST) using all the cities that need to be visited
 *    (including the start city, end city, and required points). An MST is a tree that connects all points with the minimum total edge weight.
 * 2. **Depth-First Search (DFS)**: Perform a DFS traversal on the MST to generate a path that visits all cities at least once.
 *    This path forms an Eulerian circuit, ensuring that each node is visited at least once.
 * 3. **Path Optimization**: Since the DFS traversal can result in repeated visits to the same city, we remove duplicate cities from the
 *    path during path recovery to get a valid approximation solution.
 * 
 * This approach offers a lower time complexity compared to brute-force and dynamic programming methods and provides a 2-approximation
 * solution to TSP, meaning the length of the path generated by this method is at most twice the length of the optimal solution.
 * 
 * **Algorithm Steps**:
 * 1. Calculate the shortest path between all pairs of cities (using Dijkstra's algorithm).
 * 2. Build a subgraph that includes the start city, end city, and all required points.
 * 3. Apply Kruskal's algorithm to construct the Minimum Spanning Tree (MST) of this subgraph.
 * 4. Use DFS to generate a traversal path of the MST, and remove duplicate cities to get the final path.
 * 
 * **Use Cases**:
 * - When the number of cities is large (e.g., `n > 10`), MST approximation is more efficient than brute-force or dynamic programming.
 * - For TSP variants with multiple required points, MST offers a fast and reasonably accurate approximation solution.
 * 
 * **Note**:
 * - This algorithm provides an approximate solution and does not guarantee the optimal path. However, in many cases, it provides
 *   a path that is very close to the optimal.
 * - The time complexity of this algorithm is `O(n^2 * (n + m) * log n)`, making it efficient for sparse graphs and larger datasets.
 * - You can adjust the `calculateTotalDistance()` method to support different types of graphs (weighted, undirected, etc.).
 * 
 * **Related Data Structures**:
 * - **Disjoint Set (Union-Find)** is used to help Kruskal's algorithm for merging cities in the MST.
 * - **Dijkstra's Algorithm** is used to calculate the shortest paths between pairs of cities.
 */

package com.example.calculations;

import com.example.graph.*;
import java.util.*;

public class CalcMST {

    public List<String> calculateRoute(String startingCity, String endingCity, List<String> attractions, Graph graph, Map<String, Attraction> attractionLocations) {
        long startTime = System.nanoTime();

        Set<String> allCityNames = new HashSet<>();
        allCityNames.add(startingCity);
        allCityNames.add(endingCity);
        for (String attraction : attractions) {
            allCityNames.add(attractionLocations.get(attraction).getLocation());
        }
        allCityNames.addAll(graph.getadjList().keySet());

        List<String> allCities = new ArrayList<>(allCityNames);
        int n = allCities.size();

        Map<String, Integer> cityToIndex = new HashMap<>();
        Map<Integer, String> indexToCity = new HashMap<>();
        for (int i = 0; i < n; i++) {
            cityToIndex.put(allCities.get(i), i);
            indexToCity.put(i, allCities.get(i));
        }

        // Precompute all-pairs shortest paths
        Map<String, Map<String, List<String>>> allPaths = new HashMap<>();
        for (String from : allCities) {
            allPaths.put(from, new HashMap<>());
            for (String to : allCities) {
                if (from.equals(to)) {
                    allPaths.get(from).put(to, new ArrayList<>(List.of(from)));
                } else {
                    List<String> path = graph.dijkstra(from, to);
                    allPaths.get(from).put(to, path);
                }
            }
        }

        List<String> requiredLocations = new ArrayList<>();
        for (String attr : attractions) {
            requiredLocations.add(attractionLocations.get(attr).getLocation());
        }

        List<String> bestPath = null;
        int minTotalDist = Integer.MAX_VALUE;

        for (List<String> perm : permutations(requiredLocations)) {
            List<String> candidatePath = new ArrayList<>();
            int totalDist = 0;
            String current = startingCity;

            for (String next : perm) {
                List<String> segment = allPaths.get(current).get(next);
                totalDist += calculateTotalDistance(segment, graph);
                if (!candidatePath.isEmpty()) segment = segment.subList(1, segment.size());
                candidatePath.addAll(segment);
                current = next;
            }

            List<String> finalSegment = allPaths.get(current).get(endingCity);
            totalDist += calculateTotalDistance(finalSegment, graph);
            if (!candidatePath.isEmpty()) finalSegment = finalSegment.subList(1, finalSegment.size());
            candidatePath.addAll(finalSegment);

            if (totalDist < minTotalDist) {
                minTotalDist = totalDist;
                bestPath = candidatePath;
            }
        }

        System.out.println((System.nanoTime()-startTime)/1e6);

        return bestPath;
    }

    public int calculateTotalDistance(List<String> path, Graph graph) {
        int totalDistance = 0;
        for (int i = 0; i < path.size() - 1; i++) {
            String city1 = path.get(i);
            String city2 = path.get(i + 1);
            totalDistance += graph.getadjList().get(city1).get(city2);
        }
        return totalDistance;
    }

    private List<List<String>> permutations(List<String> items) {
        List<List<String>> result = new ArrayList<>();
        permute(items, 0, result);
        return result;
    }

    private void permute(List<String> items, int start, List<List<String>> result) {
        if (start == items.size()) {
            result.add(new ArrayList<>(items));
            return;
        }
        for (int i = start; i < items.size(); i++) {
            Collections.swap(items, i, start);
            permute(items, start + 1, result);
            Collections.swap(items, i, start);
        }
    }
} 
